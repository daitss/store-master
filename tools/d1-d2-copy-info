#!/usr/bin/env ruby
# -*- mode: ruby; -*-

# one-off program to fixup the migrated DAITSS 1 data from the pools to the DAITSS 2
# copy table

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '../lib/')

require 'datyl/reporter'
require 'datyl/streams'
require 'optparse'
require 'store-master'

def setup config
  Logger.setup('FixupCopies', config.server_name)

  if config.syslog_facility
    Logger.facility  = config.syslog_facility
  else
    Logger.stderr 
  end

  DataMapper::Logger.new(Logger.new(:info, 'DataMapper:'), :debug)
  StoreMasterModel::Package.server_location = "http://#{config.server_name}"
  StoreMasterModel.setup_db(config.db_config_file, config.db_store_master_key)
  Daitss.setup_db(config.db_config_file, config.db_daitss_key)
end

Struct.new('Config', :server_name, :db_config_file, :db_store_master_key, :db_daitss_key, :required_copies)

def parse_options args

  conf = Struct::Config.new(nil, '/opt/fda/etc/db.yml', nil, nil, 2)

  opts = OptionParser.new do |opts|
    opts.on("--server-name HOSTNAME",  String, "The virtual hostname of the store-master web service") do |host_name|
      conf.server_name = host_name
    end
    opts.on("--db-config-file PATH", String, "A database yaml configuration file, defaults to #{conf.db_config_file}") do |path|
      conf.db_config_file = path
    end
    opts.on("--db-store-master-key KEY", String, "The key for the store master database in the database yaml configuration file")  do |key|
      conf.db_store_master_key = key
    end
    opts.on("--db-daitss-key KEY", String, "The key for the daitss database in the database yaml configuration file") do |key|
      conf.db_daitss_key = key
    end
    opts.on("--required-copies NUM", Integer, "Optionally, the number of required pool copies we'll need (defaults to #{conf.required_copies})") do |num|
      conf.required_copies = num
    end
  end
  opts.parse!(args)

  raise "Configuration yaml file #{conf.db_config_file} not found"                                     unless File.exists? conf.db_config_file
  raise "No store-master database key to the DB configuration file (#{conf.db_config_file}) provided"  unless conf.db_store_master_key
  raise "No daitss database key to the DB configuration file (#{conf.db_config_file}) provided"        unless conf.db_daitss_key
  raise "Configuration yaml file #{conf.db_config_file} not readable"                                  unless File.readable? conf.db_config_file

rescue => e
  STDERR.puts e, opts
  STDERR.puts e.backtrace.join("\n")
  return nil
else
  return conf
end

def sha1_inconsistent? pool_data_array, daitss_data
  pool_data_array.inconsistent? :sha1 or pool_data_array[0].sha1 != daitss_data.sha1
end

def size_inconsistent? pool_data_array, daitss_data
  pool_data_array.inconsistent? :size or pool_data_array[0].size.to_i != daitss_data.size.to_i
end

def md5_inconsistent? pool_data_array, daitss_data
  pool_data_array.inconsistent? :md5 or pool_data_array[0].md5 != daitss_data.md5
end


config = parse_options(ARGV) or exit
setup(config)

begin
  # Get our data streams, some from web services, some from various databases

  pool_fixity_streams  = StoreMasterModel::Pool.list_active.map { |pool| Streams::PoolFixityStream.new(pool) }
  daitss_fixity_stream = Streams::DaitssPackageStream.new

  comparison_stream   = Streams::ComparisonStream.new(Streams::StoreUrlMultiFixities.new(pool_fixity_streams), daitss_fixity_stream)

  comparison_stream.each do |key, pool_data, daitss_data|
    puts key, pool_data.inspect, daitss_data.inspect, ''
  end

end

rescue => e
  Logger.err  "#{e.class}: #{e.message} - backtrace follows:"
  e.backtrace.each { |line| Logger.err line }
end
