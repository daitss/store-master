#!/usr/bin/env ruby
# -*- mode: ruby; -*-

# TODO:  print out all configuration information in log

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '../lib/')

require 'datyl/reporter'
require 'datyl/streams'
require 'optparse'
require 'store-master'

def setup config
  $0 = 'collect-fixities'
  Logger.setup('CollectFixities', config.server_address)

  if config.syslog_facility
    Logger.facility  = config.syslog_facility
  else
    Logger.stderr
  end

  if config.pid_directory
    pid_path = StoreUtils.pid_file(config.pid_directory)
    raise "PID file #{pid_path} exists. This indicates another copy of this script is running or has previously crashed; exiting"   if File.exists? pid_path
    File.open(pid_path, 'w') { |file|  file.puts $$ }
  end

  # DataMapper::Logger.new(Logger.new(:info, 'DataMapper:'), :debug)
  Reporter.max_lines_to_write = 3000   # each report will have at most these lines, though everything will go to syslog
  StoreMasterModel::Package.server_location = "http://#{config.server_address}"  # TODO: crummy backdoor way, rethink
  StoreMasterModel.setup_db(config.db_config_file, config.db_store_master_key)
  Daitss.setup_db(config.db_config_file, config.db_daitss_key)
end


def teardown config, streams
  if config.pid_directory
    pid_path = StoreUtils.pid_file(config.pid_directory)
    File.delete pid_path if File.exists? pid_path and File.writable? pid_path
  end

end


# MAIN:

config = FixityUtils.parse_options(ARGV) or exit
setup(config)

begin
  start_time = DateTime.now

  Reporter.note "CollectFixities started at #{Time.now}"

  # Get our data streams, some from web services, some from various databases

  pool_fixity_streams  = StoreMasterModel::Pool.list_active.map { |pool| Streams::PoolFixityStream.new(pool) }
  daitss_fixity_stream = Streams::DaitssPackageStream.new(:before => start_time)

  reports = []

  reports.concat Analyzer::PoolVsDaitssAnalyzer.new(pool_fixity_streams, daitss_fixity_stream, config.required_copies, config.expiration_days, start_time).run.reports

  # TODO: these turn out to be somewhat redundant, maybe put into their own script?
  #
  # store_master_stream  = Streams::StoreMasterPackageStream.new
  #
  # reports.concat Analyzer::IntraPoolAnalyzer.new(pool_fixity_streams, config.expiration_days).run.reports
  # reports.concat Analyzer::InterPoolAnalyzer.new(pool_fixity_streams, config.required_copies).run.reports
  # reports.concat Analyzer::StoreMasterAnalyzer.new(store_master_stream, config.required_copies).run.reports
  # reports.concat Analyzer::StoreMasterVsPoolAnalyzer.new(store_master_stream, pool_fixity_streams).run.reports

  reports.each { |report| report.write if report.interesting? }

  Reporter.note "CollectFixities finished at #{Time.now}"

rescue => e
  lede = "#{e.class}: #{e.message} - backtrace follows:"

  STDERR.puts lede
  e.backtrace.each { |line| STDERR.puts line }

  Logger.err  lede
  e.backtrace.each { |line| Logger.err line }
else
  teardown(config, pool_fixity_streams)
end
