#!/usr/bin/env ruby
# -*- mode: ruby; -*-

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '../lib/')

require 'csv'
require 'datyl/streams'
require 'datyl/reporter'
require 'store-master/fixity/analyzer'
require 'store-master/fixity/pool-stream'
require 'store-master/fixity/utils'
require 'net/http'
require 'optparse'
require 'store-master'
require 'tempfile'
require 'uri'


DATAMAPPER_LOG_LEVEL = :debug

# DATAMAPPER_LOG_LEVEL = nil

# Given a directory, return a path to a PID file in it, named after this script

def construct_pid_path directory
  File.join(directory, $0.split(File::SEPARATOR).pop + '.pid')
end


def setup config
  Logger.setup('CollectFixities')

  if config.syslog_facility
    Logger.facility  = config.syslog_facility
  else
    Logger.stderr 
  end

  if config.pid_directory
    pid_path = construct_pid_path(config.pid_directory)
    raise "PID file #{pid_path} exists. This indicates another copy of this script is running or has previously crashed; exiting"   if File.exists? pid_path
    File.open(pid_path, 'w') { |file|  file.puts $$ }
  end

  DataMapper::Logger.new(Logger.new(:info, 'DataMapper:'), DATAMAPPER_LOG_LEVEL)  if DATAMAPPER_LOG_LEVEL
  StoreMasterModel.setup_db(config.db_config_file, config.db_store_master_key)
end

def teardown config, streams

  if config.pid_directory
    pid_path = construct_pid_path(config.pid_directory)
    File.delete pid_path if File.exists? pid_path and File.writable? pid_path
  end

  streams.each { |s| s.close unless s.closed? }
end

# Given a directory, return a path to a PID file in it, named after this script


config = FixityUtils.parse_options(ARGV)

setup(config)

reports = []

begin
  # Get streams for our basic fixity data from each pool; we'll be
  # using them repeatedly.  Recall each stream of this type yields the
  # key/value pairs <String:package>, <Struct:PoolFixityRecord>

  pool_fixity_streams = StoreMasterModel::Pool.list_active.map { |p| Streams::PoolFixityStream.new(p) }

  reports.concat Analyzer::IntraPoolAnalyzer.new(pool_fixity_streams).run.reports
  reports.concat Analyzer::InterPoolAnalyzer.new(pool_fixity_streams, config.required_copies).run.reports

  reports.each { |report| report.write }  # if report.interesting? }

rescue => e
  ### TODO: go to logger with this as well as STDERR.
  STDERR.puts e
  e.backtrace.each { |line| STDERR.puts line }
ensure
  teardown(config, pool_fixity_streams)
end

