#!/usr/bin/env ruby
# -*- mode: ruby; -*-

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '../lib/')

require 'datyl/reporter'
require 'datyl/streams'
require 'optparse'
require 'store-master'

DATAMAPPER_LOG_LEVEL = :debug

# DATAMAPPER_LOG_LEVEL = nil

# Given a directory, return a path to a PID file in it, named after this script

def construct_pid_path directory
  File.join(directory, $0.split(File::SEPARATOR).pop + '.pid')
end


def setup config
  Logger.setup('CollectFixities')

  if config.syslog_facility
    Logger.facility  = config.syslog_facility
  else
     Logger.stderr 
   end

   if config.pid_directory
     pid_path = construct_pid_path(config.pid_directory)
     raise "PID file #{pid_path} exists. This indicates another copy of this script is running or has previously crashed; exiting"   if File.exists? pid_path
     File.open(pid_path, 'w') { |file|  file.puts $$ }
   end

  DataMapper::Logger.new(Logger.new(:info, 'DataMapper:'), DATAMAPPER_LOG_LEVEL)  if DATAMAPPER_LOG_LEVEL
  StoreMasterModel.setup_db(config.db_config_file, config.db_store_master_key)

  ## DaitssModel.setup_db(config.db_config_file, config.db_daitss_key)

end

def teardown config, streams
  if config.pid_directory
    pid_path = construct_pid_path(config.pid_directory)
    File.delete pid_path if File.exists? pid_path and File.writable? pid_path
  end
  streams.each { |s| s.close unless s.closed? }
end

config = FixityUtils.parse_options(ARGV)

begin

  setup(config)

  pool_fixity_streams = StoreMasterModel::Pool.list_active.map { |pool| Streams::PoolFixityStream.new(pool) }
  store_master_stream = Streams::StoreMasterPackageStream.new

  reports = []

  reports.concat Analyzer::IntraPoolAnalyzer.new(pool_fixity_streams, config.expiration_days).run.reports
  reports.concat Analyzer::InterPoolAnalyzer.new(pool_fixity_streams, config.required_copies).run.reports
  reports.concat Analyzer::StoreMasterAnalyzer.new(store_master_stream, config.required_copies).run.reports
  reports.concat Analyzer::StoreMasterVsPoolAnalyzer.new(store_master_stream, pool_fixity_streams).run.reports

  # reports.each { |report| report.write if report.interesting? }

  reports.each { |report| report.write }

rescue => e
  Logger.err  "#{e.class}: #{e.message} - backtrace follows"
  e.backtrace.each { |line| Logger.err line }

  STDERR.puts "#{e.class}: #{e.message} - backtrace follows"
  e.backtrace.each { |line| STDERR.puts line }

ensure
  teardown(config, pool_fixity_streams)
end
